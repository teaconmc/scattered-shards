plugins {
    id "com.github.johnrengelman.shadow"
    id 'maven-publish'
    id 'java-library'
}

architectury {
    platformSetupLoomIde()
    neoForge()
}

loom {
    accessWidenerPath = project(":common").loom.accessWidenerPath
}

configurations {
    common
    shadowCommon // Don't use shadow from the shadow plugin since it *excludes* files.
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentNeoForge.extendsFrom common
}

dependencies {
    neoForge "net.neoforged:neoforge:${rootProject.neoforge_version}"
    // Remove the next line if you don't want to depend on the API
    modApi "dev.architectury:architectury-neoforge:${rootProject.architectury_version}"

    common(project(path: ":common", configuration: "namedElements")) { transitive false }
    shadowCommon(project(path: ":common", configuration: "transformProductionNeoForge")) { transitive = false }
}

repositories {
    maven { url "https://maven.neoforged.net/releases/" }
}

processResources {
    inputs.property "version", project.version

    filesMatching("META-INF/neoforge.mods.toml") {
        expand "version": project.version
    }
}

shadowJar {
    exclude "fabric.mod.json"
    exclude "architectury.common.json"

    configurations = [project.configurations.shadowCommon]
    archiveClassifier = "dev-shadow"

    dependencies {
        it.exclude it.dependency('io.netty:.*')
    }
    relocate "reactor", "vendor.cn.zbx1425.scatteredshards.reactor"
    relocate "io.lettuce", "vendor.cn.zbx1425.scatteredshards.lettuce"
    relocate "org.reactivestreams", "vendor.cn.zbx1425.scatteredshards.reactivestreams"
}

remapJar {
    input.set shadowJar.archiveFile
    dependsOn shadowJar
    
    atAccessWideners.add loom.accessWidenerPath.get().asFile.name
}

sourcesJar {
    def commonSources = project(":common").sourcesJar
    dependsOn commonSources
    from commonSources.archiveFile.map { zipTree(it) }
}

components.java {
    withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
        skip()
    }
}


publishing {
    publications {
        // Modified by TeaCon
        register('release', MavenPublication) {
            // noinspection GroovyAssignabilityCheck
            from components.java
            version = rootProject.mod_version
            groupId = rootProject.maven_group
            artifactId = "$mod_github_repo-NeoForge-$rootProject.minecraft_version"
            pom {
                name = mod_github_repo
                url = "https://github.com/$mod_github_owner/$mod_github_repo"
                licenses {
                    license {
                        name = mod_license
                        url = "https://github.com/$mod_github_owner/$mod_github_repo/blob/HEAD/LICENSE"
                    }
                }
                organization {
                    name = 'TeaConMC'
                    url = 'https://github.com/teaconmc'
                }
                developers {
                    for (mod_author in "$mod_authors".split(',')) {
                        developer { id = mod_author.trim(); name = mod_author.trim() }
                    }
                }
                issueManagement {
                    system = 'GitHub Issues'
                    url = "https://github.com/$mod_github_owner/$mod_github_repo/issues"
                }
                scm {
                    url = "https://github.com/$mod_github_owner/$mod_github_repo"
                    connection = "scm:git:git://github.com/$mod_github_owner/${mod_github_repo}.git"
                    developerConnection = "scm:git:git@github.com:$mod_github_owner/${mod_github_repo}.git"
                }
            }
        }
    }
    repositories {
        // Modified by TeaCon
        maven {
            name "teacon"
            url "s3://maven/"
            credentials(AwsCredentials) {
                accessKey = System.env.ARCHIVE_ACCESS_KEY
                secretKey = System.env.ARCHIVE_SECRET_KEY
            }
        }
    }
}

// Added by TeaCon
tasks.withType(PublishToMavenRepository).configureEach {
    if (repository && repository.name == "archive") {
        it.onlyIf {
            System.env.MAVEN_USERNAME && System.env.MAVEN_PASSWORD
        }
    }
}

abstract class TeaConDumpPathToGitHub extends DefaultTask {
    @Input
    abstract Property<String> getPublishName()
    @InputFile
    abstract RegularFileProperty getTargetFile()
    @TaskAction
    void dump() {
        if (System.env.GITHUB_ACTIONS) {
            File theFile = targetFile.getAsFile().get()

            def outputFile = new File(System.env.GITHUB_OUTPUT)
            // Use the env-specific line separator for maximally possible compatibility
            def newLine = System.getProperty('line.separator')

            // Write out new env variable for later usage
            outputFile << newLine << "artifact_name=${theFile.getName()}"
            outputFile << newLine << "artifact_publish_name=${publishName.get()}"
            outputFile << newLine << "artifact_path=${theFile.absolutePath}"
        }
    }
}

// Added by TeaCon
tasks.register("githubActionOutput", TeaConDumpPathToGitHub) { task ->
    task.onlyIf { System.env.GITHUB_ACTIONS }
    task.getTargetFile().set(jar.archiveFile)
    task.getPublishName().set("${jar.archiveBaseName.get()}-${version}.jar")
}

